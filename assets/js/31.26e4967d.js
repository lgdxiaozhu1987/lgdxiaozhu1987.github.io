(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{402:function(v,_,e){"use strict";e.r(_);var t=e(21),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"正则表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[v._v("#")]),v._v(" 正则表达式")]),v._v(" "),e("h2",{attrs:{id:"正则语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则语法"}},[v._v("#")]),v._v(" 正则语法")]),v._v(" "),e("h3",{attrs:{id:"单个字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单个字符"}},[v._v("#")]),v._v(" 单个字符")]),v._v(" "),e("ol",[e("li",[v._v("换行符："),e("code",[v._v("\\n")]),v._v("，记忆方法："),e("strong",[v._v("n")]),v._v("ew line;")]),v._v(" "),e("li",[v._v("换页符："),e("code",[v._v("\\f")]),v._v("，记忆方法："),e("strong",[v._v("f")]),v._v("orm feed;")]),v._v(" "),e("li",[v._v("回车符："),e("code",[v._v("\\r")]),v._v("，记忆方法："),e("strong",[v._v("r")]),v._v("eturn;")]),v._v(" "),e("li",[v._v("空白符："),e("code",[v._v("\\s")]),v._v("，记忆方法："),e("strong",[v._v("s")]),v._v("pace;")]),v._v(" "),e("li",[v._v("制表符："),e("code",[v._v("\\t")]),v._v("，记忆方法："),e("strong",[v._v("t")]),v._v("able;")])]),v._v(" "),e("h3",{attrs:{id:"多个字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多个字符"}},[v._v("#")]),v._v(" 多个字符")]),v._v(" "),e("ol",[e("li",[v._v("定义集合："),e("code",[v._v("[]")]),v._v("，例如"),e("code",[v._v("/[123]/")]),v._v("可以同时匹配 1，2，3 三个字符；")]),v._v(" "),e("li",[e("code",[v._v("[0-9]")]),v._v("匹配所有数字，"),e("code",[v._v("[a-z]")]),v._v("匹配所有小写英文字母，"),e("code",[v._v("[A-Z]")]),v._v("匹配所有小写英文字母， "),e("code",[v._v("[\\u4e00-\\u9fa5]")]),v._v("匹配所有的汉子；")]),v._v(" "),e("li",[v._v("匹配除了换行符之外的任何字符："),e("code",[v._v(".")]),v._v("，记忆方法：代表句号，表示除了句子结束符")]),v._v(" "),e("li",[v._v("匹配单个数字[0-9]，"),e("code",[v._v("\\d")]),v._v("，记忆方法："),e("strong",[v._v("d")]),v._v("igit;")]),v._v(" "),e("li",[v._v("匹配除了[0-9]，"),e("code",[v._v("\\D")]),v._v("，记忆方法："),e("strong",[v._v("not d")]),v._v("igit;")]),v._v(" "),e("li",[v._v("匹配包括下划线在内的单个字符，[A-Za-z0-9_]，"),e("strong",[v._v("\\w")]),v._v("，记忆方法："),e("strong",[v._v("w")]),v._v("ord;")]),v._v(" "),e("li",[v._v("匹配非单字字符，"),e("code",[v._v("\\W")]),v._v("，记忆方法："),e("strong",[v._v("not w")]),v._v("ord;")]),v._v(" "),e("li",[v._v("匹配空白字符,包括空格、制表符、换页符和换行符，"),e("strong",[v._v("\\s")]),v._v("，记忆方法："),e("strong",[v._v("s")]),v._v("pace；")]),v._v(" "),e("li",[v._v("匹配非空白字符，"),e("code",[v._v("\\S")]),v._v("，记忆方法："),e("strong",[v._v("not s")]),v._v("pace")])]),v._v(" "),e("h3",{attrs:{id:"匹配次数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#匹配次数"}},[v._v("#")]),v._v(" 匹配次数")]),v._v(" "),e("ol",[e("li",[v._v("元字符"),e("code",[v._v("?")]),v._v("代表了匹配 1 个字符或 0 个字符，例如同时匹配"),e("code",[v._v("color")]),v._v("和"),e("code",[v._v("colour")]),v._v("，可以使用"),e("code",[v._v("/colou?r/")]),v._v("。")]),v._v(" "),e("li",[v._v("元字符"),e("code",[v._v("*")]),v._v("用来表示匹配同个字符出现 0 次或多次的情况。")]),v._v(" "),e("li",[v._v("元字符"),e("code",[v._v("+")]),v._v("适用于要匹配同个字符出现 1 次或多次的情况。")]),v._v(" "),e("li",[v._v("特定的重复次数：使用元字符"),e("code",[v._v("{")]),v._v("和"),e("code",[v._v("}")]),v._v("用来给重复匹配设置精确的区间范围。如想匹配 3 次'a'，使用/a{3}/，如果匹配至少两次'a'用/a{2,}/，详细信息：\n"),e("ul",[e("li",[e("code",[v._v("{x}")]),v._v(": x 次")]),v._v(" "),e("li",[e("code",[v._v("{min, max}")]),v._v("： 介于 min 次到 max 次之间")]),v._v(" "),e("li",[e("code",[v._v("{min, }")]),v._v(": 至少 min 次")]),v._v(" "),e("li",[e("code",[v._v("{0, max}")]),v._v("： 至多 max 次")])])])]),v._v(" "),e("h3",{attrs:{id:"单词与字符串边界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单词与字符串边界"}},[v._v("#")]),v._v(" 单词与字符串边界")]),v._v(" "),e("p",[v._v("单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。这时需要用边界正则表达式"),e("code",[v._v("\\b")]),v._v("，例如对于例句：")]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("The cat scattered his food all over the room"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("\n")])])]),e("p",[v._v("想找 cat 这个单词，如果只是使用"),e("code",[v._v("/cat/")]),v._v("，会同时匹配到 cat 和 scattered 这两处文本。这时需使用边界正则表达式"),e("code",[v._v("\\b")]),v._v("，其中 b 是 boundary 的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。上面的例子改写成"),e("code",[v._v("/\\bcat\\b/")]),v._v("这样就能匹配到 cat 这个单词了。")]),v._v(" "),e("p",[v._v("对于字符串来说，元字符"),e("code",[v._v("^")]),v._v("用来匹配字符串的开头。而元字符"),e("code",[v._v("$")]),v._v("用来匹配字符串的末尾。")]),v._v(" "),e("h3",{attrs:{id:"分组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分组"}},[v._v("#")]),v._v(" 分组")]),v._v(" "),e("p",[v._v("其中分组体现在：所有以"),e("code",[v._v("(")]),v._v("和"),e("code",[v._v(")")]),v._v("元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。")]),v._v(" "),e("p",[v._v("所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像"),e("code",[v._v("\\1")]),v._v(","),e("code",[v._v("\\2")]),v._v(",....,其中"),e("code",[v._v("\\1")]),v._v("表示引用的第一个子表达式，"),e("code",[v._v("\\2")]),v._v("表示引用的第二个子表达式，以此类推。而"),e("code",[v._v("\\0")]),v._v("则表示"),e("strong",[v._v("整个表达式")]),v._v("。")])])}),[],!1,null,null,null);_.default=a.exports}}]);